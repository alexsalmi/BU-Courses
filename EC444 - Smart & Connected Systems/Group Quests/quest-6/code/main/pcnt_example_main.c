// QUEST 4: Autonomous Crawler
// TEAM 17: Karle Erf, Thuc Nguyen, Alex Salmi

// Main code for our crawler. Several different tasks perform the different required functionalities:
// wheel speed control, steering using the microlidars (UART), communication with the server through UDP, and displaying the current speed to the I2C 14-segment display

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/portmacro.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/periph_ctrl.h"
#include "driver/ledc.h"
#include "driver/gpio.h"
#include "driver/uart.h"
#include "driver/pcnt.h"
#include "driver/i2c.h"
#include "esp_attr.h"
#include "esp_vfs_dev.h"
#include "esp_log.h"
#include "sdkconfig.h"
#include "esp_types.h"
#include "driver/gpio.h"
#include "driver/timer.h"
#include "driver/periph_ctrl.h"
#include "esp_system.h"
#include "string.h"
#include "esp_wifi.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "tcpip_adapter.h"


#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include <lwip/netdb.h>

#include "driver/mcpwm.h"
#include "soc/mcpwm_periph.h"

#include "esp_attr.h"

#include "driver/mcpwm.h"
#include "soc/mcpwm_periph.h"

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include <lwip/netdb.h>
#include "esp_attr.h"

#include "driver/adc.h"
#include "esp_adc_cal.h"

/**
 * TEST CODE BRIEF
 *
 * Use PCNT module to count rising edges generated by LEDC module.
 *
 * Functionality of GPIOs used in this example:
 *   - GPIO18 - output pin of a sample 1 Hz pulse generator,
 *   - GPIO4 - pulse input pin,
 *   - GPIO5 - control input pin.
 *
 * Load example, open a serial port to view the message printed on your screen.
 *
 * To do this test, you should connect GPIO18 with GPIO4.
 * GPIO5 is the control signal, you can leave it floating with internal pull up,
 * or connect it to ground. If left floating, the count value will be increasing.
 * If you connect GPIO5 to GND, the count value will be decreasing.
 *
 * An interrupt will be triggered when the counter value:
 *   - reaches 'thresh1' or 'thresh0' value,
 *   - reaches 'l_lim' value or 'h_lim' value,
 *   - will be reset to zero.
 */
#define PCNT_TEST_UNIT      PCNT_UNIT_0
#define PCNT_H_LIM_VAL      10
#define PCNT_L_LIM_VAL     -10
#define PCNT_THRESH1_VAL    5
#define PCNT_THRESH0_VAL   -5
#define PCNT_INPUT_SIG_IO   4  // Pulse Input GPIO
#define PCNT_INPUT_CTRL_IO  5  // Control GPIO HIGH=count up, LOW=count down
#define LEDC_OUTPUT_IO      18 // Output GPIO of a sample 1 Hz pulse generator

//alphanumeric defines
#define ALPHA_ADDR                         0x70 // alphanumeric address
#define LIDAR_ADDR                         0x62 // LIDAR address
#define OSC                                0x21 // oscillator cmd
#define HT16K33_BLINK_DISPLAYON            0x01 // Display on cmd
#define HT16K33_BLINK_OFF                  0    // Blink off cmd
#define HT16K33_BLINK_CMD                  0x80 // Blink cmd
#define HT16K33_CMD_BRIGHTNESS             0xE0 // Brightness cmd
// Master I2C
#define I2C_EXAMPLE_MASTER_SCL_IO          22   // gpio number for i2c clk
#define I2C_EXAMPLE_MASTER_SDA_IO          23   // gpio number for i2c data
#define I2C_EXAMPLE_MASTER_NUM             I2C_NUM_0  // i2c port
#define I2C_EXAMPLE_MASTER_TX_BUF_DISABLE  0    // i2c master no buffer needed
#define I2C_EXAMPLE_MASTER_RX_BUF_DISABLE  0    // i2c master no buffer needed
#define I2C_EXAMPLE_MASTER_FREQ_HZ         100000     // i2c master clock freq
#define WRITE_BIT                          I2C_MASTER_WRITE // i2c master write
#define READ_BIT                           I2C_MASTER_READ  // i2c master read
#define ACK_CHECK_EN                       true // i2c master will check ack
#define ACK_CHECK_DIS                      false// i2c master will not check ack
#define ACK_VAL                            0x00 // i2c ack value
#define NACK_VAL                           0xFF // i2c nack value
#define BUF_SIZE (1024)
#define BLINK_GPIO 12
#define ECHO_TEST_TXD  (GPIO_NUM_4)
#define ECHO_TEST_RXD  (GPIO_NUM_5)
#define ECHO_TEST_RTS  (UART_PIN_NO_CHANGE)
#define ECHO_TEST_CTS  (UART_PIN_NO_CHANGE)

//timer interupt constants
#define TIMER_DIVIDER         16    //  Hardware timer clock divider
#define TIMER_SCALE           (TIMER_BASE_CLK / TIMER_DIVIDER)  // to seconds
#define TIMER_INTERVAL_SEC   (1)    // Sample test interval for the first timer
#define TEST_WITH_RELOAD      1     // Testing will be done with auto reload

static const int RX_BUF_SIZE = 1024;

#define TXD_PIN_LEFT (GPIO_NUM_17)
#define RXD_PIN_LEFT (GPIO_NUM_16)

#define TXD_PIN_RIGHT (GPIO_NUM_33)
#define RXD_PIN_RIGHT (GPIO_NUM_15)

#define TXD_PIN_RECIEVER (GPIO_NUM_25)
#define RXD_PIN_RECIEVER (GPIO_NUM_39)

//You can get these value from the datasheet of servo you use, in general pulse width varies between 1000 to 2000 mocrosecond
#define SERVO_MIN_PULSEWIDTH 800 //Minimum pulse width in microsecond
#define SERVO_MAX_PULSEWIDTH 2100 //Maximum pulse width in microsecond

#define DEFAULT_VREF    1100        //Use adc2_vref_to_gpio() to obtain a better estimate
#define NO_OF_SAMPLES   64          //Multisampling

static esp_adc_cal_characteristics_t *adc_chars;
static const adc_channel_t channel = ADC_CHANNEL_6;     //GPIO34 if ADC1, GPIO14 if ADC2
static const adc_atten_t atten = ADC_ATTEN_DB_0;
static const adc_unit_t unit = ADC_UNIT_1;

#define HOST_IP_ADDR "192.168.1.36"

#define PORT 8080

static const char *TAG = "data";
#define SERVO_MAX_DEGREE 90 //Maximum angle in degree upto which servo can rotate

int16_t count = 0; //count of times sensor has seen black or white in 1 second
//uint16_t total_dist = 0;
double speed = 0;
bool turn = false;
bool on = true;
bool stop = true;
bool remote = false;

int index_of_code; //codde is the value read from the beacon stoplights red green or yellow
int traffic_light; //value of the traffic light

uint16_t displaybuffer [4];
/* static const uint16_t alphafonttable[]  = {


        0b0000110000111111, // 0
        0b0000000000000110, // 1
        0b0000000011011011, // 2
        0b0000000010001111, // 3
        0b0000000011100110, // 4
        0b0010000001101001, // 5
        0b0000000011111101, // 6
        0b0000000000000111, // 7
        0b0000000011111111, // 8
        0b0000000011101111, // 9


}; */


xQueueHandle pcnt_evt_queue;   // A queue to handle pulse counter events
pcnt_isr_handle_t user_isr_handle = NULL; //user's ISR service handle

/* A sample structure to pass events from the PCNT
 * interrupt handler to the main program.
 */
typedef struct {
    int unit;  // the PCNT unit that originated an interrupt
    uint32_t status; // information on the event type that caused the interrupt
} pcnt_evt_t;

void init_servo(){
   mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0B, 12); 

    //2. initial mcpwm configuration
    printf("Configuring Initial Parameters of mcpwm......\n");
    mcpwm_config_t pwm_configB;
    pwm_configB.frequency = 50;    //frequency = 50Hz, i.e. for every servo motor time period should be 20ms
    pwm_configB.cmpr_a = 0;    //duty cycle of PWMxA = 0
    pwm_configB.cmpr_b = 0;    //duty cycle of PWMxb = 0
    pwm_configB.counter_mode = MCPWM_UP_COUNTER;
    pwm_configB.duty_mode = MCPWM_DUTY_MODE_0;
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, &pwm_configB);    //Configure PWM0A & PWM0B with above settings    
}
/* Decode what PCNT's unit originated an interrupt
 * and pass this information together with the event type
 * the main program using a queue.
 */

// Function to initiate i2c -- note the MSB declaration!
/*
static void i2c_example_master_init(){
    // Debug
    printf("\n>> i2c Config\n");
    int err;
    // Port configuration
    int i2c_master_port = I2C_EXAMPLE_MASTER_NUM;
    // gpio_pad_select_gpio(BLINK_GPIO);
    // gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
    // uart_config_t uart_config = {
    //         .baud_rate = 115200,
    //         .data_bits = UART_DATA_8_BITS,
    //         .parity    = UART_PARITY_DISABLE,
    //         .stop_bits = UART_STOP_BITS_1,
    //         .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    // };
    // uart_param_config(UART_NUM_0, &uart_config);
    // uart_set_pin(UART_NUM_0, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    // uart_driver_install(UART_NUM_0, BUF_SIZE * 2, 0, 0, NULL, 0);
    // esp_vfs_dev_uart_use_driver(UART_NUM_0);
    /// Define I2C configurations
    i2c_config_t conf;
    conf.mode = I2C_MODE_MASTER;                              // Master mode
    conf.sda_io_num = I2C_EXAMPLE_MASTER_SDA_IO;              // Default SDA pin
    conf.sda_pullup_en = GPIO_PULLUP_ENABLE;                  // Internal pullup
    conf.scl_io_num = I2C_EXAMPLE_MASTER_SCL_IO;              // Default SCL pin
    conf.scl_pullup_en = GPIO_PULLUP_ENABLE;                  // Internal pullup
    conf.master.clk_speed = I2C_EXAMPLE_MASTER_FREQ_HZ;       // CLK frequency
    err = i2c_param_config(i2c_master_port, &conf);           // Configure
    if (err == ESP_OK) {printf("- parameters: ok\n");}
    // Install I2C driver
    err = i2c_driver_install(i2c_master_port, conf.mode,
                             I2C_EXAMPLE_MASTER_RX_BUF_DISABLE,
                             I2C_EXAMPLE_MASTER_TX_BUF_DISABLE, 0);
    // i2c_set_data_mode(i2c_master_port,I2C_DATA_MODE_LSB_FIRST,I2C_DATA_MODE_LSB_FIRST);
    if (err == ESP_OK) {printf("- initialized: yes\n\n");}
    // Dat in MSB mode
    i2c_set_data_mode(i2c_master_port, I2C_DATA_MODE_MSB_FIRST, I2C_DATA_MODE_MSB_FIRST);
}*/

void uart_init(void) {
    const uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    const uart_config_t uart_config_2 = {
        .baud_rate = 1200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    uart_param_config(UART_NUM_1, &uart_config);
    uart_set_pin(UART_NUM_1, TXD_PIN_LEFT, RXD_PIN_LEFT, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    // We won't use a buffer for sending data.
    uart_driver_install(UART_NUM_1, RX_BUF_SIZE * 2, 0, 0, NULL, 0);

/*     uart_param_config(UART_NUM_2, &uart_config);
    uart_set_pin(UART_NUM_2, TXD_PIN_RIGHT, RXD_PIN_RIGHT, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    // We won't use a buffer for sending data.
    uart_driver_install(UART_NUM_2, RX_BUF_SIZE * 2, 0, 0, NULL, 0); */

    uart_param_config(UART_NUM_2, &uart_config_2);
    uart_set_pin(UART_NUM_2, TXD_PIN_RECIEVER, RXD_PIN_RECIEVER, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_set_line_inverse(UART_NUM_2, UART_INVERSE_RXD);
    // We won't use a buffer for sending data.
    uart_driver_install(UART_NUM_2, RX_BUF_SIZE * 2, 0, 0, NULL, 0);
}

// Utility  Functions //////////////////////////////////////////////////////////
// Utility function to test for I2C device address -- not used in deploy
/*
int testConnection(uint8_t devAddr, int32_t timeout) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (devAddr << 1) | I2C_MASTER_WRITE, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    int err = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    return err;
}
*/
// Utility function to scan for i2c device
/*
static void i2c_scanner() {
    int32_t scanTimeout = 1000;
    printf("\n>> I2C scanning ..."  "\n");
    uint8_t count = 0;
    for (uint8_t i = 1; i < 127; i++) {
        // printf("0x%X%s",i,"\n");
        if (testConnection(i, scanTimeout) == ESP_OK) {
            printf( "- Device found at address: 0x%X%s", i, "\n");
            count++;
        }
    }
    if (count == 0)
        printf("- No I2C devices found!" "\n");
    printf("\n");
}*/

////////////////////////////////////////////////////////////////////////////////
// Alphanumeric Functions //////////////////////////////////////////////////////
// Turn on oscillator for alpha display
int alpha_oscillator() {
    int ret;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, ( ALPHA_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, OSC, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    vTaskDelay(200 / portTICK_RATE_MS);
    return ret;
}

// Set blink rate to off
int no_blink() {
    int ret;
    i2c_cmd_handle_t cmd2 = i2c_cmd_link_create();
    i2c_master_start(cmd2);
    i2c_master_write_byte(cmd2, ( ALPHA_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd2, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | (HT16K33_BLINK_OFF << 1), ACK_CHECK_EN);
    i2c_master_stop(cmd2);
    ret = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd2, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd2);
    vTaskDelay(200 / portTICK_RATE_MS);
    return ret;
}

// Set Brightness
int set_brightness_max(uint8_t val) {
    int ret;
    i2c_cmd_handle_t cmd3 = i2c_cmd_link_create();
    i2c_master_start(cmd3);
    i2c_master_write_byte(cmd3, ( ALPHA_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd3, HT16K33_CMD_BRIGHTNESS | val, ACK_CHECK_EN);
    i2c_master_stop(cmd3);
    ret = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd3, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd3);
    vTaskDelay(200 / portTICK_RATE_MS);
    return ret;
}

// Write one byte to register
/*
int writeRegister(uint8_t reg, uint8_t data) {
    int ret;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, ( LIDAR_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, reg, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, data, ACK_CHECK_EN); //was disabled 
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    vTaskDelay(100/portTICK_RATE_MS);  //previously no delay here
    return ret;
}*/

// Read register
/*
uint16_t readRegister(uint8_t reg) {
    uint8_t temp1, temp2;
    uint16_t total_data;
    int ret1, ret2;
    i2c_cmd_handle_t cmd1 = i2c_cmd_link_create(); //command for reg
    i2c_cmd_handle_t cmd2 = i2c_cmd_link_create(); //command for data
    i2c_master_start(cmd1);
    i2c_master_write_byte(cmd1, ( LIDAR_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd1, reg, ACK_CHECK_EN);
    i2c_master_stop(cmd1);
    ret1 = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd1, 1000 / portTICK_RATE_MS);
    i2c_master_start(cmd2);
    i2c_master_write_byte(cmd2, ( LIDAR_ADDR << 1) | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd2, &temp1, ACK_VAL); //take in upper byte from reg //instead of ACK_VAL it was ACK CHECK EN
    i2c_master_read_byte(cmd2, &temp2, ACK_VAL); //take in lower byte from reg //instead of ACK_VAL it was ACK CHECK EN
    i2c_master_stop(cmd2);
    ret2 = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd2, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd1);
    i2c_cmd_link_delete(cmd2);
    total_data =  (uint16_t)(temp1 | temp2); //bitwise or upper and lower to get total
    return total_data;
}*/

////////////////////////////////////////////////////////////////////////////////

static void test_alpha_display() {
    // Debug
    int ret;
    printf(">> Test Alphanumeric Display: \n");
    //uint8_t *data = (uint8_t *) malloc(BUF_SIZE);
    //int len = 0;
    // Set up routines
    // Turn on alpha oscillator
    ret = alpha_oscillator();
    if(ret == ESP_OK) {printf("- oscillator: ok \n");}
    // Set display blink off
    ret = no_blink();
    if(ret == ESP_OK) {printf("- blink: off \n");}
    ret = set_brightness_max(0xF);
    if(ret == ESP_OK) {printf("- brightness: max \n");}

    
    //char str[10];
    while (1) {
        
        // Send commands characters to display over I2C
        i2c_cmd_handle_t cmd4 = i2c_cmd_link_create();
        i2c_master_start(cmd4);
        i2c_master_write_byte(cmd4, ( ALPHA_ADDR << 1 ) | WRITE_BIT, ACK_CHECK_EN);
        i2c_master_write_byte(cmd4, (uint8_t)0x00, ACK_CHECK_EN);
        for (uint8_t i=0; i<8; i++) {
            i2c_master_write_byte(cmd4, displaybuffer[i] & 0xFF, ACK_CHECK_EN);
            i2c_master_write_byte(cmd4, displaybuffer[i] >> 8, ACK_CHECK_EN);
        }
        i2c_master_stop(cmd4);
        ret = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd4, 1000 / portTICK_RATE_MS);
        i2c_cmd_link_delete(cmd4);
        if(ret == ESP_OK) {
            //printf("- wrote: T.D.C.L. \n\n");
        }
    }
}

static uint32_t servo_per_degree_init(uint32_t degree_of_rotation)
{
    uint32_t cal_pulsewidth = 0;
    cal_pulsewidth = (SERVO_MIN_PULSEWIDTH + (((SERVO_MAX_PULSEWIDTH - SERVO_MIN_PULSEWIDTH) * (degree_of_rotation)) / (SERVO_MAX_DEGREE)));
    return cal_pulsewidth;
}

static void rx_task(void *arg)
{
    printf("Initializing Rx\n");
    static const char *RX_TASK_TAG = "RX_TASK";
    esp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);
    uint8_t* data_Left = (uint8_t*) malloc(RX_BUF_SIZE+1);


    uint32_t angle;

    while (1) {
        const int rxBytes_Left = uart_read_bytes(UART_NUM_1, data_Left, RX_BUF_SIZE, 1000 / portTICK_RATE_MS);
        if(!turn && !remote){
            if (rxBytes_Left > 0) {
                data_Left[rxBytes_Left] = 0;
                int raw_Left = 0;
                double count_Left = 0.0;

                for(int i=0; i<rxBytes_Left-2; i++){
                    if(data_Left[i] == 0x59 && data_Left[i+1] == 0x59){
                        raw_Left += data_Left[i+2];
                        count_Left += 1;
                    }
                }
                double dist_Left = raw_Left / count_Left;

                printf("Distance Left: %f cm\n\n", dist_Left);

            
                if(dist_Left > 75 ){
                    angle = servo_per_degree_init(60);
                    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);
                }
                else if(dist_Left < 75 ){
                    angle = servo_per_degree_init(20);
                    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);                
                }
                else{
                    angle = servo_per_degree_init(40);
                    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);                  
                }
                

            }
        }


    }

    free(data_Left);
}

 /*
 Initialize PCNT functions:
 *  - configure and initialize PCNT
 *  - set up the input filter
 *  - set up the counter events to watch
 */
static void pcnt_example_init(void)
{
    /* Prepare configuration for the PCNT unit */
    pcnt_config_t pcnt_config = {
        // Set PCNT input signal and control GPIOs
        .pulse_gpio_num = 27, //input pin that recieves the pulse
        .ctrl_gpio_num = PCNT_INPUT_CTRL_IO, //control gpio for high (up) and low (down) ?????
        .channel = PCNT_CHANNEL_0,
        .unit = PCNT_TEST_UNIT,
        // What to do on the positive / negative edge of pulse input?
        .pos_mode = PCNT_COUNT_INC,   // Count up on the positive edge
        .neg_mode = PCNT_COUNT_DIS,   // Keep the counter value on the negative edge
        // What to do when control input is low or high?
        .lctrl_mode = PCNT_COUNT_DIS, // Reverse counting direction if low
        .hctrl_mode = PCNT_COUNT_DIS,    // Keep the primary counter mode if high
        // Set the maximum and minimum limit values to watch
        .counter_h_lim = PCNT_H_LIM_VAL,
        .counter_l_lim = PCNT_L_LIM_VAL,
    };
    /* Initialize PCNT unit */
    pcnt_unit_config(&pcnt_config);

    /* Configure and enable the input filter */
    pcnt_set_filter_value(PCNT_TEST_UNIT, 100);
    pcnt_filter_enable(PCNT_TEST_UNIT);

    /* Set threshold 0 and 1 values and enable events to watch */
    pcnt_set_event_value(PCNT_TEST_UNIT, PCNT_EVT_THRES_1, PCNT_THRESH1_VAL);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_THRES_1);
    pcnt_set_event_value(PCNT_TEST_UNIT, PCNT_EVT_THRES_0, PCNT_THRESH0_VAL);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_THRES_0);
    /* Enable events on zero, maximum and minimum limit values */
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_ZERO);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_H_LIM);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_L_LIM);

    /* Initialize PCNT's counter */
    pcnt_counter_pause(PCNT_TEST_UNIT);
    pcnt_counter_clear(PCNT_TEST_UNIT);

    /* Register ISR handler and enable interrupts for PCNT unit */
    // pcnt_isr_register(pcnt_example_intr_handler, NULL, 0, &user_isr_handle);
    // pcnt_intr_enable(PCNT_TEST_UNIT);

    /* Everything is set up, now go to counting */
    pcnt_counter_resume(PCNT_TEST_UNIT);
}

// A simple structure to pass "events" to main task
typedef struct {
    int flag;     // flag for enabling stuff in main code
    int cnt;
} timer_event_t;

// Initialize queue handler for timer-based events
xQueueHandle timer_queue;

// ISR handler
void IRAM_ATTR timer_group0_isr(void *para) {

    // Prepare basic event data, aka set flag
    timer_event_t evt;
    evt.flag = 1; 

    // Clear the interrupt, Timer 0 in group 0
    TIMERG0.int_clr_timers.t0 = 1;

    // After the alarm triggers, we need to re-enable it to trigger it next time
    TIMERG0.hw_timer[TIMER_0].config.alarm_en = TIMER_ALARM_EN;

    // Send the event data back to the main program task
    xQueueSendFromISR(timer_queue, &evt, NULL);
}

// Initialize timer 0 in group 0 for 1 sec alarm interval and auto reload
static void alarm_init() {
    /* Select and initialize basic parameters of the timer */
    timer_config_t config;
    config.divider = TIMER_DIVIDER;
    config.counter_dir = TIMER_COUNT_UP;
    config.counter_en = TIMER_PAUSE;
    config.alarm_en = TIMER_ALARM_EN;
    config.intr_type = TIMER_INTR_LEVEL;
    config.auto_reload = TEST_WITH_RELOAD;
    timer_init(TIMER_GROUP_0, TIMER_0, &config);

    // Timer's counter will initially start from value below
    timer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0x00000000ULL);

    // Configure the alarm value and the interrupt on alarm
    timer_set_alarm_value(TIMER_GROUP_0, TIMER_0, TIMER_INTERVAL_SEC * TIMER_SCALE);
    timer_enable_intr(TIMER_GROUP_0, TIMER_0);
    timer_isr_register(TIMER_GROUP_0, TIMER_0, timer_group0_isr,
        (void *) TIMER_0, ESP_INTR_FLAG_IRAM, NULL);

    // Start timer
    timer_start(TIMER_GROUP_0, TIMER_0);
}

// The main task of this example program
static void timer_evt_task(void *arg) {
    while (1) {
        // Create dummy structure to store structure from queue
        timer_event_t evt;

        // Transfer from queue
        xQueueReceive(timer_queue, &evt, portMAX_DELAY);

        // Do something if triggered!
        if (evt.flag == 1) {
            double revs = 0;
            double rpm = 0;
            pcnt_get_counter_value(PCNT_TEST_UNIT, &count);
            revs = (count*50) / 12.0;
            pcnt_counter_clear(PCNT_TEST_UNIT);
            rpm = revs / 60.0;
            speed = rpm * 0.62;
            printf("Speed is: %0.2f m/s\n count is: %d\n", speed, count);
            
            
        }

    }

}

//ultrasonic functions---------------------
static void check_efuse(void)
{
    //Check TP is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP) == ESP_OK) {
        printf("eFuse Two Point: Supported\n");
    } else {
        printf("eFuse Two Point: NOT supported\n");
    }

    //Check Vref is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_VREF) == ESP_OK) {
        printf("eFuse Vref: Supported\n");
    } else {
        printf("eFuse Vref: NOT supported\n");
    }
}

static void print_char_val_type(esp_adc_cal_value_t val_type)
{
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        printf("Characterized using Two Point Value\n");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        printf("Characterized using eFuse Vref\n");
    } else {
        printf("Characterized using Default Vref\n");
    }
}

void ultrasonic_task(void)
{
    //Check if Two Point or Vref are burned into eFuse
    check_efuse();

    //Configure ADC
    if (unit == ADC_UNIT_1) {
        adc1_config_width(ADC_WIDTH_BIT_10);
        adc1_config_channel_atten(channel, atten);
    } else {
        adc2_config_channel_atten((adc2_channel_t)channel, atten);
    }

    //Characterize ADC
    adc_chars = calloc(1, sizeof(esp_adc_cal_characteristics_t));
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(unit, atten, ADC_WIDTH_BIT_10, DEFAULT_VREF, adc_chars);
    print_char_val_type(val_type);

    //Continuously sample ADC1
    while (1) {
        // if(!remote){
        uint32_t adc_reading = 0;
            //Multisampling
            for (int i = 0; i < NO_OF_SAMPLES; i++) {
                if (unit == ADC_UNIT_1) {
                    adc_reading += adc1_get_raw((adc1_channel_t)channel);
                } else {
                    int raw;
                    adc2_get_raw((adc2_channel_t)channel, ADC_WIDTH_BIT_10, &raw);
                    adc_reading += raw;
                }
            }
            adc_reading /= NO_OF_SAMPLES;
            //Convert adc_reading to voltage in mV
            uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, adc_chars);
            printf("Raw: %d\tVoltage: %dmV     ", adc_reading, voltage);
            int dist = adc_reading*5;
            if(dist < 2750 && dist > 750){
                turn = true;
            }
            else{
                turn = false;
            }        
            printf("Distance: %d mm\n",dist);
            vTaskDelay(pdMS_TO_TICKS(500));
        // }
    }
}


//DRIVING FUNTIONS-----------------------

void calibrateESC() {

    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0A, 18); 
    mcpwm_config_t pwm_configA;
    pwm_configA.frequency = 50;    //frequency = 50Hz, i.e. for every servo motor time period should be 20ms
    pwm_configA.cmpr_a = 0;    //duty cycle of PWMxA = 0
    pwm_configA.cmpr_b = 0;    //duty cycle of PWMxb = 0
    pwm_configA.counter_mode = MCPWM_UP_COUNTER;
    pwm_configA.duty_mode = MCPWM_DUTY_MODE_0;
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, &pwm_configA);    //Configure PWM0A & PWM0B with above settings

    vTaskDelay(3000 / portTICK_PERIOD_MS);  // Give yourself time to turn on crawler
    printf("setting speed to HIGH\n");
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 2100); // HIGH signal in microseconds
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    printf("setting speed to LOW\n");
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 700);  // LOW signal in microseconds
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    printf("setting speed to NEUTRAL\n");
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400); // NEUTRAL signal in microseconds
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400); // reset the ESC to neutral (non-moving) value
    vTaskDelay(1000 / portTICK_PERIOD_MS);
}

void forward_turn(){
    //mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400);
    //  for(int i  = 1400; i > 1200; i = i - 10){
    //     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, i);
    //     vTaskDelay(25 / portTICK_PERIOD_MS);
    // } 
     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1275);

}

void forward_straight(){
    //mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400);
    //  for(int i  = 1400; i > 1270; i = i - 10){
    //     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, i);
    //     vTaskDelay(25 / portTICK_PERIOD_MS);
    // } 
     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1275);

}

void forward_remote(){
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1275);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400);
}

void reverse_remote(){
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1525);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400);
}

void steer_right(){
    uint32_t angle;
    angle = servo_per_degree_init(0);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);    
}

void steer_left(){
    uint32_t angle;
    angle = servo_per_degree_init(90);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);    
}

void steer_straight(){
    uint32_t angle;
    angle = servo_per_degree_init(40);
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);    
}

void neutral(){
    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 1400);
}

time_t start_time, end_time;
bool got_start_time = true;
bool got_split_time = false;
float split = 0.0;
float prev_split = 0.0;
bool send_split = false;

static void rx_task_beacon_reader(void *arg)
{
    static const char *RX_TASK_TAG = "RX_TASK";
    esp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);
    uint8_t* data = (uint8_t*) malloc(RX_BUF_SIZE+1);
    printf("Reading...\n");
    
    while (1) {
        index_of_code = 0;
        //printf("Reading...\n");
        const int rxBytes = uart_read_bytes(UART_NUM_2, data, RX_BUF_SIZE, 100 / portTICK_RATE_MS);
        //printf("bytes:  %d",rxBytes);
        if (rxBytes > 0) {
            for(int i  = 0; i < rxBytes; i++){
                if(data[i] == 0x1b){
                    index_of_code = i+1;

                }
            }

            data[rxBytes] = 0;
            //printf("the code is %hhn\n", code);
            if(data[index_of_code] == 0x47){ // GREEN
                if(!got_start_time){
                    time(&start_time);
                }
                got_split_time = false;
                stop = false;
                //printf("RUN FOREST RUN\n");
            }
            else if(data[index_of_code] == 0x52 || data[index_of_code] == 0x59){ // RED  YELLOW
                if(got_start_time && !got_split_time){
                    time(&end_time);
                    split = difftime(end_time, start_time);
                    got_split_time = true;
                    send_split = true;
                }
                stop = true;
                //printf("RUN THAT RED BITCH\n");
            }
            //printf("Read %d bytes: '%x' '%x' '%x' '%x' '%x' '%x'\n", rxBytes, data[0], data[1], data[2], data[3], data[4], data[5]);
            printf("the code after 1b is: '%x'\n",data[index_of_code]);

        }
    }
    free(data);
}

void test(){
    uint32_t angle;
    
    while(1){
        // if(!remote){
            if(!stop){
                if(turn){
                    //printf("turning\n");
                    forward_turn();
                    angle = servo_per_degree_init(0);
                    mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);
                    // vTaskDelay(12000 / portTICK_PERIOD_MS);
                    //turn = false;
                    //printf("turn finished\n");
                }
                else if(!turn){
                    forward_straight();
                }
            }
            else if(stop){
                neutral();
            }
        // }

        // else if(!turn){
        //     angle = servo_per_degree_init(40);
        //     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);            
        // }
        // else{
        //     angle = servo_per_degree_init(40);
        //     mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);            
        // }
    }  
}
/*
void LIDAR(){
    while (1){ //v3 lidar lite reg write to initiate acquisition
        int lidar_start = writeRegister(0x00, 0x04);
        int check_result = 1;
        while (check_result) { //v3 low bit check
            //printf("running low bit check\n");
            uint8_t check_low = readRegister(0x01);
            check_result = check_low & (1 << 7);
        }
        printf("low bit check done\n");
        printf("reading data in\n");
        uint16_t total_dist = readRegister(0x8F); //read multibyte reg
        if(total_dist < 225 && total_dist > 50){
            turn = true;
        }
        else{
            turn = false;
        }
        printf("Total Distance: %u\n", total_dist);

        vTaskDelay(500 / portTICK_PERIOD_MS);
    }
}*/

void sendData(){
    char rx_buffer[128];
    char addr_str[128];
    int addr_family;
    int ip_protocol;

    while (1) {
        struct sockaddr_in dest_addr;
        dest_addr.sin_addr.s_addr = inet_addr(HOST_IP_ADDR);
        dest_addr.sin_family = AF_INET;
        dest_addr.sin_port = htons(PORT);
        addr_family = AF_INET;
        ip_protocol = IPPROTO_IP;
        inet_ntoa_r(dest_addr.sin_addr, addr_str, sizeof(addr_str) - 1);

        int sock = socket(addr_family, SOCK_DGRAM, ip_protocol);
        if (sock < 0) {
            ESP_LOGE(TAG, "Unable to create socket: errno %d", errno);
            break;
        }
        ESP_LOGI(TAG, "Socket created, sending to %s:%d", HOST_IP_ADDR, PORT);

        while (1) {
            if(send_split){
                float diff = split - prev_split;
                char buf[64];
                sprintf(&buf, "%g", diff);
                int err = sendto(sock, buf, strlen("hello"), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
                if (err < 0) {
                    ESP_LOGE(TAG, "Error occurred during sending: errno %d", errno);
                    break;
                }
                ESP_LOGI(TAG, "Message sent");

                while(send_split || remote){
                    send_split = false;
                    struct sockaddr_in source_addr; // Large enough for both IPv4 or IPv6
                    socklen_t socklen = sizeof(source_addr);
                    int len = recvfrom(sock, rx_buffer, sizeof(rx_buffer) - 1, 0, (struct sockaddr *)&source_addr, &socklen);

                    // Error occurred during receiving
                    if (len < 0) {
                        ESP_LOGE(TAG, "recvfrom failed: errno %d", errno);
                        break;
                    }
                    // Data received
                    else {
                        rx_buffer[len] = 0; // Null-terminate whatever we received and treat like a string
                        ESP_LOGI(TAG, "Received %d bytes from %s:", len, addr_str);
                        ESP_LOGI(TAG, "%s", rx_buffer);

                        if(rx_buffer[0] == 't'){
                            stop = !stop;
                            remote = !remote;
                            neutral();
                        }
                        else if(rx_buffer[0] == 'f'){
                            forward_remote();
                        }
                        else if(rx_buffer[0] == 'l'){
                            steer_left();
                        }
                        else if(rx_buffer[0] == 'r'){
                            steer_right();
                        }
                        else if(rx_buffer[0] == 's'){
                            steer_straight();
                        }
                        else if(rx_buffer[0] == 'd'){
                            reverse_remote();
                        }
                    }
                }
            }


            vTaskDelay(1000 / portTICK_PERIOD_MS);
        }

        if (sock != -1) {
            ESP_LOGE(TAG, "Shutting down socket and restarting...");
            shutdown(sock, 0);
            close(sock);
        }
    }
    vTaskDelete(NULL);
}

void app_main(void)
{
    calibrateESC();
    pcnt_example_init(); //counter init
    alarm_init();
    uart_init();
    
    timer_queue = xQueueCreate(10, sizeof(timer_event_t));
    //i2c_example_master_init(); //alpha init
    //i2c_scanner();

    init_servo();

    uint32_t angle;
    //angle = servo_per_degree_init(0);
    //mcpwm_set_duty_in_us(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, angle);
    //1. mcpwm gpio initialization
    //mcpwm_example_gpio_initialize();


    //xTaskCreate(timer_evt_task, "timer_evt_task", 2048, NULL, 5, NULL);
    //xTaskCreate(LIDAR, "LIDAR", 4096, NULL, 1, NULL);
    xTaskCreate(test, "driving", 4096, NULL, 5, NULL);
    xTaskCreate(rx_task, "uart_rx_task", 4096, NULL, 3, NULL);
    //xTaskCreate(test_alpha_display,"display speed", 4096, NULL, 4, NULL);
    xTaskCreate(rx_task_beacon_reader, "beacon reader", 4096, NULL, 1, NULL);
    xTaskCreate(ultrasonic_task, "front sensor", 4096, NULL, 2, NULL);
    //xTaskCreate(sendData,"server_comms",4096,NULL,4,NULL);



    if(user_isr_handle) {
        //Free the ISR service handle.
        esp_intr_free(user_isr_handle);
        user_isr_handle = NULL;
    }
}
